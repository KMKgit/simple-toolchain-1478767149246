{"changed":true,"filter":false,"title":"k_means.py","tooltip":"/py/k_means/k_means.py","value":"from __future__ import division\nimport sys\nimport csv\nimport matplotlib.pylab as plt\nimport cPickle\nimport json\nimport numpy as np\nimport codecs\nfrom os import getcwd\nfrom os import environ\nfrom os.path import dirname\nfrom os.path import join\nfrom os.path import exists\nfrom os.path import expanduser\nfrom os.path import isdir\nfrom os.path import splitext\nfrom os import listdir\nfrom os import mkdir\nfrom os import path\nfrom numpy import genfromtxt\nfrom sklearn import datasets\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score, recall_score, precision_score, f1_score\nfrom sklearn.externals import joblib\nfrom sklearn.cluster import KMeans\nfrom sklearn.datasets import make_blobs\ntry:\n  PATH = getcwd()\n  f = open(PATH + '/data/' + sys.argv[1] + '/' + sys.argv[1] + '.info', 'r')\n  p = open(PATH + '/data/' + sys.argv[1] + '/' + sys.argv[1] + '.param', 'r')\n  columns = f.read().splitlines()\n  t = json.load(p)\n  k = int(t['k'])\n  random_seed = int(t['random_seed'])\n  f.close()\n  p.close()\n  \n  with codecs.open(join(PATH + '/data/' + sys.argv[1] + '/' + sys.argv[1] + '.csv'), encoding = 'utf-8-sig') as csv_file:\n    reader = csv.reader(csv_file)\n    csv_data = list(reader)\n    n_samples = len(csv_data) - 1\n    n_features = len(csv_data[0])\n    data = np.empty((n_samples, 2))\n    \n    for i in range(n_samples):\n      temp = []\n      for j in range(n_features):\n        temp.append(csv_data[i+1][j])\n      data[i] = np.asarray(temp, dtype=np.float)\n      \n  \n  \n  transformation = [[ 0.60834549, -0.63667341], [-0.40887718, 0.85253229]]\n  data_aniso = np.dot(data, transformation)\n  \n  if (random_seed == 0){\n    k_means = KMeans(n_clusters=k).fit(data)\n    k_means_tf = KMeans(n_clusters=k).fit(data_aniso)\n  }\n  else{\n    k_means = KMeans(n_clusters=k, random_state=random_seed).fit(data)\n    k_means_tf = KMeans(n_clusters=k, random_state=random_seed).fit(data_aniso)\n  }\n  \n  P = k_means.predict(data)\n  AP = k_means_tf.predict(data_aniso)\n  \n  out = open(PATH + '/data/' + sys.argv[1] + '/' + sys.argv[1] + '.out', 'w')\n  retP = []\n  retAP = []\n  for i in range(len(P)):\n    retP.append(str(P[i]));\n    retAP.append(str(AP[i]));\n  json.dump({'ntb':\n              {\n                'samples' : n_samples\n              }\n            ,\n            'tb': \n              {\n                'predict' : retP,\n                'aniso_predict' : retAP\n              }\n            }, out, separators=(',',':'))\n  if not path.exists(PATH + '/data/' + sys.argv[1] + '/pkl'):\n    mkdir(PATH + '/data/' + sys.argv[1] + '/pkl')\n  joblib.dump(k_means, PATH + '/data/' + sys.argv[1] + '/pkl/' + sys.argv[1] + '.pkl')\n  joblib.dump(k_means_tf, PATH + '/data/' + sys.argv[1] + '/pkl/' + sys.argv[1] + '_tf.pkl')\n  out.close()\nexcept:\n  print >> sys.stderr, sys.exc_info()[0]","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":90,"column":2},"end":{"row":90,"column":37},"action":"remove","lines":["print \"ERROR : \", sys.exc_info()[0]"],"id":2},{"start":{"row":90,"column":2},"end":{"row":90,"column":40},"action":"insert","lines":["print >> sys.stderr, sys.exc_info()[0]"]}]]},"ace":{"folds":[],"scrolltop":789.5999827384949,"scrollleft":0,"selection":{"start":{"row":90,"column":40},"end":{"row":90,"column":40},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":224,"mode":"ace/mode/python"}},"timestamp":1477340807907}